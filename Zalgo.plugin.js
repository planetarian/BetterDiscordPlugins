//META{"name":"Zalgo","displayName":"Zalgo","website":"https://github.com/planetarian/BetterDiscordPlugins","source":"https://raw.githubusercontent.com/planetarian/BetterDiscordPlugins/master/Zalgo.plugin.js"}*//
/*@cc_on
@if (@_jscript)

	// Offer to self-install for clueless users that try to run this directly.
	var shell = WScript.CreateObject("WScript.Shell");
	var fs = new ActiveXObject("Scripting.FileSystemObject");
	var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\BetterDiscord\plugins");
	var pathSelf = WScript.ScriptFullName;
	// Put the user at ease by addressing them in the first person
	shell.Popup("It looks like you've mistakenly tried to run me directly. \n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
	if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
		shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
	} else if (!fs.FolderExists(pathPlugins)) {
		shell.Popup("I can't find the BetterDiscord plugins folder.\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
	} else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
		fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
		// Show the user where to put plugins in the future
		shell.Exec("explorer " + pathPlugins);
		shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
	}
	WScript.Quit();

@else@*/

let Zalgo = (() => {
  const config = {
    "info": {
      "name": "Zalgo",
      "authors": [{
        "name": "Chami",
        "discord_id": "165709167095578625",
        "github_username": "planetarian",
        "twitter_username": "pir0zhki"
      }],
      "version": "0.5.0",
      "description": "Zalgo text generation plugin -- write something {{like this}} to corrupt it lÃïiÕúÃ∏Ã∂kÕÅÕüeÕèÕ¢Ã∂ Ã®ÃõtÃ¢Ãõ“âÃßhÃßÕòiÕòÃïÕèÕüÕÅsÕòÃßÃ∏Ã¢Õè\r\nYou can configure the amount of corruption in settings, or prefix it with a corruption amount:\r\n{{0.01:just a little corrupt}} -> jÃ®uÃ®sÕètÃ® Ã∑aÕò Ã∏lÃ∂iÃ∑tÕÄt“âlÕ°e“â Ã¥cÃ°oÕèr“ârÕÅuÃ°pÃ¢tÃï\r\nYou can also ramp the corruption amount gradually:\r\n{{r:start at zero and get more corrupted}} -> stÃ∂aÃ∑rÃ∏tÕú “âaÃ¥tÃ° ÕòzÃ¢eÃµrÃµoÕ° ÕùaÃ°nÕÅdÃ° ÃõgÕùeÕûtÕèÃ∑ ÕúmÕüoÃ°ÕÅrÕ†ÃïeÃ∏Ã¥ “âÃ®ÕücÕ†ÕÄÕ¢Ã®oÕùÃïÕûÃïÃõrÕ¢Ã∏Ã°ÃµrÃõÕÅÕûuÃßpÕùÃ®ÕütÃ¥ÕùÃ∂eÃ°Ã∑dÕèÕ°Ã¥ÕÅ",
      "github": "https://github.com/planetarian/BetterDiscordPlugins",
      "github_raw": "https://raw.githubusercontent.com/planetarian/BetterDiscordPlugins/master/Zalgo.plugin.js"
    },
    "changelog": [{
      "title": "0.5.0",
      "items": ["Added new text transformers: cursive (ùìΩùìÆùìºùìΩ), goth (ùñôùñäùñòùñô), flipped ( á«ùs á), small (·µó·µâÀ¢·µó), and mirrored (∆ö…òÍôÖ∆ö) ",
      "To use them, simply set the transformation mode to the first letter of the transform you want to use. For example, cursive: {{c:test}}"]
    },{
      "title": "0.4.0",
      "items": ["Fixed breakage caused by discord update", "Switched from element manipulation to method patching"]
    }, {
      "title": "0.3.0",
      "items": ["Fixed breakage caused by discord update", "Switched from locally-tracked classes to use DiscordSelectors"]
    }, {"title": "Plugin revamp", "items": ["Switched to new plugin format", "Switched to new ZeresLib"]}],
    "main": "index.js"
  };

  return !global.ZeresPluginLibrary ? class {
    constructor() {
      this._config = config;
    }

    getName() {
      return config.info.name;
    }

    getAuthor() {
      return config.info.authors.map(a => a.name).join(", ");
    }

    getDescription() {
      return config.info.description;
    }

    getVersion() {
      return config.info.version;
    }

    load() {
      const title = "Library Missing";
      const ModalStack = BdApi.findModuleByProps("push", "update", "pop", "popWithKey");
      const TextElement = BdApi.findModuleByProps("Sizes", "Weights");
      const ConfirmationModal = BdApi.findModule(m => m.defaultProps && m.key && m.key() === "confirm-modal");
      if (!ModalStack || !ConfirmationModal || !TextElement) return BdApi.alert(title, `The library plugin needed for ${config.info.name} is missing.<br /><br /> <a href="https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js" target="_blank">Click here to download the library!</a>`);
      ModalStack.push(function (props) {
        return BdApi.React.createElement(ConfirmationModal, Object.assign({
          header: title,
          children: [BdApi.React.createElement(TextElement, {
            color: TextElement.Colors.PRIMARY,
            children: [`The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`]
          })],
          red: false,
          confirmText: "Download Now",
          cancelText: "Cancel",
          onConfirm: () => {
            require("request").get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", async (error, response, body) => {
              if (error) return require("electron").shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
              await new Promise(r => require("fs").writeFile(require("path").join(ContentManager.pluginsFolder, "0PluginLibrary.plugin.js"), body, r));
            });
          }
        }, props));
      });
    }

    start() {
    }

    stop() {
    }
  } : (([Plugin, Api]) => {
    const plugin = (Plugin, Library) => {

      const {Logger, DiscordModules, Patcher, Settings} = Library;

      return class Zalgo extends Plugin {
        // noinspection NonAsciiCharacters
        constructor() {
          super();

          this.zalgoUp = [
            '\u030d', /*     Ãç     */    '\u030e', /*     Ãé     */    '\u0304', /*     ÃÑ     */    '\u0305', /*     ÃÖ     */
            '\u033f', /*     Ãø     */    '\u0311', /*     Ãë     */    '\u0306', /*     ÃÜ     */    '\u0310', /*     Ãê     */
            '\u0352', /*     Õí     */    '\u0357', /*     Õó     */    '\u0351', /*     Õë     */    '\u0307', /*     Ãá     */
            '\u0308', /*     Ãà     */    '\u030a', /*     Ãä     */    '\u0342', /*     ÕÇ     */    '\u0343', /*     ÕÉ     */
            '\u0344', /*     ÕÑ     */    '\u034a', /*     Õä     */    '\u034b', /*     Õã     */    '\u034c', /*     Õå     */
            '\u0303', /*     ÃÉ     */    '\u0302', /*     ÃÇ     */    '\u030c', /*     Ãå     */    '\u0350', /*     Õê     */
            '\u0300', /*     ÃÄ     */    '\u0301', /*     ÃÅ     */    '\u030b', /*     Ãã     */    '\u030f', /*     Ãè     */
            '\u0312', /*     Ãí    */    '\u0313', /*     Ãì     */    '\u0314', /*     Ãî     */    '\u033d', /*     ÃΩ     */
            '\u0309', /*     Ãâ     */    '\u0363', /*     Õ£    */    '\u0364', /*     Õ§    */    '\u0365', /*     Õ•    */
            '\u0366', /*     Õ¶    */    '\u0367', /*     Õß    */    '\u0368', /*     Õ®    */    '\u0369', /*     Õ©    */
            '\u036a', /*     Õ™    */    '\u036b', /*     Õ´    */    '\u036c', /*     Õ¨    */    '\u036d', /*     Õ≠    */
            '\u036e', /*     ÕÆ    */    '\u036f', /*     ÕØ    */    '\u033e', /*     Ãæ     */    '\u035b', /*     Õõ     */
            '\u0346', /*     ÕÜ     */    '\u031a'  /*     Ãö     */
          ];
          this.zalgoMid = [
            '\u0315', /*     Ãï     */    '\u031b', /*     Ãõ     */    '\u0340', /*     ÕÄ     */    '\u0341', /*     ÕÅ     */
            '\u0358', /*     Õò     */    '\u0321', /*     Ã°     */    '\u0322', /*     Ã¢     */    '\u0327', /*     Ãß     */
            '\u0328', /*     Ã®     */    '\u0334', /*     Ã¥     */    '\u0335', /*     Ãµ     */    '\u0336', /*     Ã∂     */
            '\u034f', /*     Õè     */    '\u035c', /*     Õú     */    '\u035d', /*     Õù     */    '\u035e', /*     Õû     */
            '\u035f', /*     Õü     */    '\u0360', /*     Õ†     */    '\u0362', /*     Õ¢     */    '\u0338', /*     Ã∏     */
            '\u0337', /*     Ã∑     */    '\u0361', /*     Õ°     */    '\u0489'  /*    “â_    */
          ];
          this.zalgoDown = [
            '\u0316', /*     Ãñ     */    '\u0317', /*     Ãó     */    '\u0318', /*     Ãò     */    '\u0319', /*     Ãô     */
            '\u031c', /*     Ãú     */    '\u031d', /*     Ãù     */    '\u031e', /*     Ãû     */    '\u031f', /*     Ãü     */
            '\u0320', /*     Ã†     */    '\u0324', /*     Ã§     */    '\u0325', /*     Ã•     */    '\u0326', /*     Ã¶     */
            '\u0329', /*     Ã©     */    '\u032a', /*     Ã™     */    '\u032b', /*     Ã´     */    '\u032c', /*     Ã¨     */
            '\u032d', /*     Ã≠     */    '\u032e', /*     ÃÆ     */    '\u032f', /*     ÃØ     */    '\u0330', /*     Ã∞     */
            '\u0331', /*     Ã±     */    '\u0332', /*     Ã≤     */    '\u0333', /*     Ã≥     */    '\u0339', /*     Ãπ     */
            '\u033a', /*     Ã∫     */    '\u033b', /*     Ãª     */    '\u033c', /*     Ãº     */    '\u0345', /*     ÕÖ     */
            '\u0347', /*     Õá     */    '\u0348', /*     Õà     */    '\u0349', /*     Õâ     */    '\u034d', /*     Õç     */
            '\u034e', /*     Õé     */    '\u0353', /*     Õì     */    '\u0354', /*     Õî     */    '\u0355', /*     Õï     */
            '\u0356', /*     Õñ     */    '\u0359', /*     Õô     */    '\u035a', /*     Õö     */    '\u0323'  /*     Ã£     */
          ];


          this.gothCharMap = {"0":"0","1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","a":"ùñÜ","b":"ùñá","c":"ùñà","d":"ùñâ","e":"ùñä","f":"ùñã","g":"ùñå","h":"ùñç","i":"ùñé","j":"ùñè","k":"ùñê","l":"ùñë","m":"ùñí","n":"ùñì","o":"ùñî","p":"ùñï","q":"ùññ","r":"ùñó","s":"ùñò","t":"ùñô","u":"ùñö","v":"ùñõ","w":"ùñú","x":"ùñù","y":"ùñû","z":"ùñü","A":"ùï¨","B":"ùï≠","C":"ùïÆ","D":"ùïØ","E":"ùï∞","F":"ùï±","G":"ùï≤","H":"ùï≥","I":"ùï¥","J":"ùïµ","K":"ùï∂","L":"ùï∑","M":"ùï∏","N":"ùïπ","O":"ùï∫","P":"ùïª","Q":"ùïº","R":"ùïΩ","S":"ùïæ","T":"ùïø","U":"ùñÄ","V":"ùñÅ","W":"ùñÇ","X":"ùñÉ","Y":"ùñÑ","Z":"ùñÖ"};
          this.cursiveCharMap = {"0":"0","1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","a":"ùì™","b":"ùì´","c":"ùì¨","d":"ùì≠","e":"ùìÆ","f":"ùìØ","g":"ùì∞","h":"ùì±","i":"ùì≤","j":"ùì≥","k":"ùì¥","l":"ùìµ","m":"ùì∂","n":"ùì∑","o":"ùì∏","p":"ùìπ","q":"ùì∫","r":"ùìª","s":"ùìº","t":"ùìΩ","u":"ùìæ","v":"ùìø","w":"ùîÄ","x":"ùîÅ","y":"ùîÇ","z":"ùîÉ","A":"ùìê","B":"ùìë","C":"ùìí","D":"ùìì","E":"ùìî","F":"ùìï","G":"ùìñ","H":"ùìó","I":"ùìò","J":"ùìô","K":"ùìö","L":"ùìõ","M":"ùìú","N":"ùìù","O":"ùìû","P":"ùìü","Q":"ùì†","R":"ùì°","S":"ùì¢","T":"ùì£","U":"ùì§","V":"ùì•","W":"ùì¶","X":"ùìß","Y":"ùì®","Z":"ùì©"};
          this.smallCharMap = {"0":"‚Å∞","1":"¬π","2":"¬≤","3":"¬≥","4":"‚Å¥","5":"‚Åµ","6":"‚Å∂","7":"‚Å∑","8":"‚Å∏","9":"‚Åπ","a":"·µÉ","b":"·µá","c":"·∂ú","d":"·µà","e":"·µâ","f":"·∂†","g":"·µç","h":" ∞","i":"‚Å±","j":" ≤","k":"·µè","l":"À°","m":"·µê","n":"‚Åø","o":"·µí","p":"·µñ","q":"q","r":" ≥","s":"À¢","t":"·µó","u":"·µò","v":"·µõ","w":" ∑","x":"À£","y":" ∏","z":"·∂ª","A":"·¥¨","B":"·¥Æ","C":"·∂ú","D":"·¥∞","E":"·¥±","F":"·∂†","G":"·¥≥","H":"·¥¥","I":"·¥µ","J":"·¥∂","K":"·¥∑","L":"·¥∏","M":"·¥π","N":"·¥∫","O":"·¥º","P":"·¥æ","Q":"Q","R":"·¥ø","S":"À¢","T":"·µÄ","U":"·µÅ","V":"‚±Ω","W":"·µÇ","X":"À£","Y":" ∏","Z":"·∂ª","+":"‚Å∫","-":"‚Åª","=":"‚Åº","(":"‚ÅΩ",")":"‚Åæ"};
          this.mirroredCharMap = {'a':'…í','b':'d','c':'…î','e':'…ò','f':'·é∏','g':'«´','h':' ú','j':'ÍûÅ','k':' û','l':'|','n':'·¥é','p':'q','r':'…ø','s':'ÍôÖ','t':'∆ö','y':' è','z':'∆π','B':'·ô†','C':'∆Ü','D':'·ó°','E':'∆é','F':'Íüª','G':'·éÆ','J':'·Ç±','K':'‚ãä','L':'‚ÖÉ','N':'Õ∂','P':'Íüº','Q':'·ªå','R':'–Ø','S':'ÍôÑ','Z':'∆∏','1':'','2':'','3':'','4':'','5':'','6':'','7':'','&':'',';':'','[':']','(':')','{':'}','?':'‚∏Æ','<':'>','√§':'…í'+'\u0308','√ü':'·ô†','¬¥':'`','√©':'…ò'+'\u0300','√°':'…í'+'\u0300','√≥':'√≤','√∫':'√π','√â':'∆é'+'\u0300','√Å':'√Ä','√ì':'√í','√ö':'√ô','`':'¬¥','√®':'…ò'+'\u0301','√†':'…í'+'\u0301','√à':'∆é'+'\u0301','√™':'…ò'+'\u0302','√¢':'…í'+'\u0302','√ä':'∆é'+'\u0302','√ò':'·¥ì','√∏':'·¥ì'};
          this.flipCharMap = {'a':'\u0250','b':'q','c':'\u0254','d':'p','e':'\u01DD','f':'\u025F','g':'\u0253','h':'\u0265','i':'\u0131','j':'\u027E','k':'\u029E','l':'\u006C','m':'\u026F','n':'u','r':'\u0279','t':'\u0287','v':'\u028C','w':'\u028D','y':'\u028E','A':'\u2200','B':'·ô†','C':'\u0186','D':'·ó°','E':'\u018e','F':'\u2132','G':'\u2141','J':'\u017f','K':'\u22CA','L':'\u02e5','M':'W','P':'\u0500','Q':'\u038C','R':'\u1D1A','T':'\u22a5','U':'\u2229','V':'\u039B','Y':'\u2144','1':'\u21c2','2':'\u1105','3':'\u0190','4':'\u3123','5':'\u078e','6':'9','7':'\u3125','&':'\u214b','.':'\u02D9','"':'\u201e',';':'\u061b','[':']','(':')','{':'}','?':'\u00BF','!':'\u00A1',"\'":',','<':'>','\u203E':'_','\u00AF':'_','\u203F':'\u2040','\u2045':'\u2046','\u2234':'\u2235','\r':'\n','√ü':'·ô†','\u0308':'\u0324','√§':'…ê'+'\u0324','√∂':'o'+'\u0324','√º':'n'+'\u0324','√Ñ':'\u2200'+'\u0324','√ñ':'O'+'\u0324','√ú':'\u2229'+'\u0324','¬¥':'\u0317','√©':'\u01DD'+'\u0317','√°':'\u0250'+'\u0317','√≥':'o'+'\u0317','√∫':'n'+'\u0317','√â':'\u018e'+'\u0317','√Å':'\u2200'+'\u0317','√ì':'O'+'\u0317','√ö':'\u2229'+'\u0317','`':'\u0316','√®':'\u01DD'+'\u0316','√†':'\u0250'+'\u0316','√≤':'o'+'\u0316','√π':'n'+'\u0316','√à':'\u018e'+'\u0316','√Ä':'\u2200'+'\u0316','√í':'O'+'\u0316','√ô':'\u2229'+'\u0316','^':'\u032E','√™':'\u01DD'+'\u032e','√¢':'\u0250'+'\u032e','√¥':'o'+'\u032e','√ª':'n'+'\u032e','√ä':'\u018e'+'\u032e','√Ç':'\u2200'+'\u032e','√î':'O'+'\u032e','√õ':'\u2229'+'\u032e'};

          this.defaultSettings = {
            corruptionAmount: 1.0,
            rampEnd: 0.7,
            corruptUp: false,
            corruptMid: true,
            corruptDown: false
          };
        }

        onStart() {
          Logger.log("Started patching sendMessage");

          Patcher.before(DiscordModules.MessageActions, "sendMessage", (t, a) => {
            let content = a[1].content;
            // Markup format:
            // {{<o/b/c/g/f/s/m>,<r><rampEnd>,<startAmount>-<endAmount>:text}}
            // transformation mode, with text "test" (IDEs tend to render this differently than discord):
            //    o: obscure ( tÕüÕÅÕ¢eÃïÕèÕùsÃ¥Õ¢tÃ∂Õù)
            //    b: beneath (don't obscure) (tÃüÕçeÃÆsÕáÃütÃú)
            //    c: cursive (ùìΩùìÆùìºùìΩ)
            //    g: goth (ùñôùñäùñòùñô)
            //    f: flipped ( á«ùs á)
            //    t: tiny (·µó·µâÀ¢·µó)
            //    m: mirrored (∆ö…òÍôÖ∆ö)
            //    s: spongebob case (tEsT)
            // r: enable ramping
            // rampEnd: normalized value (0.0-1.0) representing ramp length, requires <r>
            // startAmount: corruption amount at start of ramp; enables ramping even without <r>
            // endamount: corruption amount at end of ramp, or across whole string if no ramp
            // text: text to apply zalgo corruption to
            const regex = /\{\{(?:(?:([obucgftms])?,?)?(?:(r)(\d+(?:\.\d+)?)?,?)?(?:(\d+(?:\.\d+)?)-)?(\d+(?:\.\d+)?)?:)?((?:(?!{{).)*?)}}/gsi;
            if (regex.test(content)) {
              content = content.replace(regex, this.doTransform.bind(this));
              if (content.length > 2000) {
                PluginUtilities.showToast("This message would exceed the 2000-character limit.\nReduce corruption amount or shorten text.\n\nLength including corruption: " + content.length, {type: 'error'});
                return;
              }
              a[1].content = content;
            }
          });
        }

        onStop() {
          /// Using patch method for now
          //let textArea = this.getChatTextArea();
          //if (textArea) textArea.off("keydown.zalgo");
          Patcher.unpatchAll();
          Logger.log("Stopped");
        }

        getSettingsPanel() {
          return Settings.SettingPanel.build(this.saveSettings.bind(this),
            new Settings.SettingGroup("Zalgo Settings", {collapsible: false, shown: true}).append(
              new Settings.Slider("Corruption amount", "Adjusts how corrupted your text becomes",
                0.05, 3.0, this.settings.corruptionAmount, (e) => {
                  this.settings.corruptionAmount = e;
                }),
              new Settings.Slider("Ramp end position", "Adjusts the endpoint of the ramp-in when using the `r` prefix",
                0.05, 1.0, this.settings.rampEnd, e => {
                  this.settings.rampEnd = e;
                }),
              new Settings.Switch("Obscure text", "Determines whether zalgo characters are placed over the text or beneath it (use the `o` or `b` prefixes to set this in-line)",
                this.settings.corruptMid, e => {
                  this.settings.corruptMid = e;
                })
            )
          );
        }


        doTransform(match, midMode, ramp, rampEnd, startAmt, endAmt, contents, _offset, _string) {
          const maxAmt = 10;
          if (midMode) midMode = midMode.toLowerCase();
          switch (midMode) {
            case "c":
              return this.charMapSub(this.cursiveCharMap, contents);
            case "g":
              return this.charMapSub(this.gothCharMap, contents);
            case "f":
              return this.charMapSub(this.flipCharMap, contents);
            case "t":
              return this.charMapSub(this.smallCharMap, contents);
            case "m":
              return this.charMapSub(this.mirroredCharMap, contents);
            case "s":
              return this.getMocking(contents);
          }
          let hasStart = startAmt >= 0 && startAmt <= maxAmt;
          let hasEnd = endAmt >= 0 && endAmt <= maxAmt;
          let hasRampEnd = rampEnd >= 0 && rampEnd <= 1;

          let corruptMid = midMode === "o" || (midMode !== "b" && this.settings.corruptMid);
          let doRamp = ramp === "r" || hasStart;

          if (!hasRampEnd) rampEnd = this.settings.rampEnd;
          // use default end amount if not provided
          if (!hasEnd) endAmt = this.settings.corruptionAmount;
          // set end/start amounts to equal if we're not ramping anyway
          if (!doRamp) startAmt = endAmt;
          // otherwise, start at 0 if we are ramping but no start provided
          else if (!hasStart) startAmt = 0;

          return this.getZalgo(contents, corruptMid, parseFloat(rampEnd), parseFloat(startAmt), parseFloat(endAmt));
        }

        getZalgo(txt, corruptMid, rampEnd, startAmt, endAmt) {
          //============================================================
          // ZALGO text script by tchouky, adapted/modified by Chami
          // See original at http://eeemo.net/
          //============================================================

          // Get saved options for corruption directions
          let config = this.settings;
          let optUp = config.corruptUp;
          let optMid = corruptMid;
          let optDown = config.corruptDown || (!optUp && !optMid);

          let newTxt = "";

          let len = txt.length;
          if (len === 0) return "";

          // Figure out at what index the ramp ends
          let rampEndIndex = len * rampEnd;

          for (let i = 0; i < len; i++) {
            if (this.isZalgoChar(txt.substr(i, 1)))
              continue;

            // Add the normal character
            newTxt += txt.substr(i, 1);

            // Normalized value (0-1.0) representing our current position within the ramp
            let rampX = rampEndIndex === 0 ? 1 : Math.min(1, i / rampEndIndex);
            // Square the ramp value to ease it in
            rampX = Math.pow(rampX, 4);
            // To determine the final corruption amount at this position
            let rampDiff = rampX * (endAmt - startAmt);
            let amt = startAmt + rampDiff;

            // Modifier of .07 for up/down corruption accounts for the fact that
            // discord only displays a small portion of the characters above/below text
            let upDownMod = 0.07;
            let numUp = amt * (this.rand(64) / 4 + 3) * upDownMod;
            let numMid = amt * (this.rand(16) / 4 + 1);
            let numDown = amt * (this.rand(64) / 4 + 3) * upDownMod;

            // upward zalgo is disabled in current version except through manual config modification
            if (optUp)
              for (let j = 0; j < numUp; j++)
                newTxt += this.randZalgo(this.zalgoUp);

            // middle corruption obscures the text itself
            if (optMid)
              for (let j = 0; j < numMid; j++)
                newTxt += this.randZalgo(this.zalgoMid);

            // downward corruption begins at the text baseline
            if (optDown)
              for (let j = 0; j < numDown; j++)
                newTxt += this.randZalgo(this.zalgoDown);
          }

          // HE COMES
          return newTxt;
        }

        // Gets an int between 0 and max
        rand(max) {
          return Math.floor(Math.random() * max);
        }

        // Gets a random char from a zalgo char table
        randZalgo(array) {
          return array[this.rand(array.length)];
        }

        // Lookup char to know if it's a zalgo char or not
        isZalgoChar(c) {
          for (let i = 0; i < this.zalgoUp.length; i++)
            if (c === this.zalgoUp[i]) return true;
          for (let i = 0; i < this.zalgoDown.length; i++)
            if (c === this.zalgoDown[i]) return true;
          for (let i = 0; i < this.zalgoMid.length; i++)
            if (c === this.zalgoMid[i]) return true;
          return false;
        }

        getMocking(text) {
          let transformed = text.slice(0, 1);
          let flipper = true;
          for (let c of text.slice(1).split("")) {
            transformed += flipper ? c.toUpperCase() : c.toLowerCase();
            flipper = !flipper;
          }
          return transformed;
        }

        charMapSub(cMap, text) {
          let out = "";
          for (let c of text.split("")) {
            out += cMap[c] || cMap[c.toLowerCase()] || c;
          }
          return out;
        }
      };

    };
    return plugin(Plugin, Api);
  })(global.ZeresPluginLibrary.buildPlugin(config));
})();
/*@end@*/
